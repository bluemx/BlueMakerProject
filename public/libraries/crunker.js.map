{"version":3,"file":"crunker.js","mappings":"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","sources":["webpack://Crunker/webpack/universalModuleDefinition","webpack://Crunker/webpack/bootstrap","webpack://Crunker/webpack/runtime/define property getters","webpack://Crunker/webpack/runtime/hasOwnProperty shorthand","webpack://Crunker/webpack/runtime/make namespace object","webpack://Crunker/./crunker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Crunker\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Crunker\"] = factory();\n\telse\n\t\troot[\"Crunker\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface CrunkerConstructorOptions {\n  /**\n   * Sample rate for Crunker's internal audio context.\n   *\n   * @default 44100\n   */\n  sampleRate: number;\n}\n\nexport type CrunkerInputTypes = string | File | Blob;\n\n/**\n * An exported Crunker audio object.\n */\nexport interface ExportedCrunkerAudio {\n  blob: Blob;\n  url: string;\n  element: HTMLAudioElement;\n}\n\n/**\n * Crunker is the simple way to merge, concatenate, play, export and download audio files using the Web Audio API.\n */\nexport default class Crunker {\n  private readonly _sampleRate: number;\n  private readonly _context: AudioContext;\n\n  /**\n   * Creates a new instance of Crunker with the provided options.\n   *\n   * If `sampleRate` is not defined, it will auto-select an appropriate sample rate\n   * for the device being used.\n   */\n  constructor({ sampleRate }: Partial<CrunkerConstructorOptions> = {}) {\n    this._context = this._createContext();\n\n    sampleRate ||= this._context.sampleRate;\n\n    this._sampleRate = sampleRate;\n  }\n\n  /**\n   * Creates Crunker's internal AudioContext.\n   *\n   * @internal\n   */\n  private _createContext(): AudioContext {\n    window.AudioContext = window.AudioContext || (window as any).webkitAudioContext || (window as any).mozAudioContext;\n    return new AudioContext();\n  }\n\n  /**\n   *\n   * The internal AudioContext used by Crunker.\n   */\n  get context(): AudioContext {\n    return this._context;\n  }\n\n  /**\n   * Asynchronously fetches multiple audio files and returns an array of AudioBuffers.\n   */\n  async fetchAudio(...filepaths: CrunkerInputTypes[]): Promise<AudioBuffer[]> {\n    return await Promise.all(\n      filepaths.map(async (filepath) => {\n        let buffer: ArrayBuffer;\n\n        if (filepath instanceof File || filepath instanceof Blob) {\n          buffer = await filepath.arrayBuffer();\n        } else {\n          buffer = await fetch(filepath).then((response) => {\n            if (response.headers.has('Content-Type') && !response.headers.get('Content-Type')!.includes('audio/')) {\n              console.warn(\n                `Crunker: Attempted to fetch an audio file, but its MIME type is \\`${\n                  response.headers.get('Content-Type')!.split(';')[0]\n                }\\`. We'll try and continue anyway. (file: \"${filepath}\")`\n              );\n            }\n\n            return response.arrayBuffer();\n          });\n        }\n\n        return await this._context.decodeAudioData(buffer);\n      })\n    );\n  }\n\n  /**\n   * Merges (layers) multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806278-968f0680-d186-11ea-9cb5-8ef2606ffcc7.png)\n   */\n  mergeAudio(buffers: AudioBuffer[]): AudioBuffer {\n    const output = this._context.createBuffer(\n      this._maxNumberOfChannels(buffers),\n      this._sampleRate * this._maxDuration(buffers),\n      this._sampleRate\n    );\n\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n        const outputData = output.getChannelData(channelNumber);\n        const bufferData = buffer.getChannelData(channelNumber);\n\n        for (let i = buffer.getChannelData(channelNumber).length - 1; i >= 0; i--) {\n          outputData[i] += bufferData[i];\n        }\n\n        output.getChannelData(channelNumber).set(outputData);\n      }\n    });\n\n    return output;\n  }\n\n  /**\n   * Concatenates multiple AudioBuffers into a single AudioBuffer.\n   *\n   * **Visual representation:**\n   *\n   * ![](https://user-images.githubusercontent.com/12958674/88806297-9d1d7e00-d186-11ea-8cd2-c64cb0324845.png)\n   */\n  concatAudio(buffers: AudioBuffer[]): AudioBuffer {\n    const output = this._context.createBuffer(\n      this._maxNumberOfChannels(buffers),\n      this._totalLength(buffers),\n      this._sampleRate\n    );\n    let offset = 0;\n\n    buffers.forEach((buffer) => {\n      for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n        output.getChannelData(channelNumber).set(buffer.getChannelData(channelNumber), offset);\n      }\n\n      offset += buffer.length;\n    });\n\n    return output;\n  }\n\n  /**\n   * Pads a specified AudioBuffer with silence from a specified start time,\n   * for a specified length of time.\n   *\n   * Accepts float values as well as whole integers.\n   *\n   * @param buffer AudioBuffer to pad\n   * @param padStart Time to start padding (in seconds)\n   * @param seconds Duration to pad for (in seconds)\n   */\n  padAudio(buffer: AudioBuffer, padStart: number = 0, seconds: number = 0): AudioBuffer {\n    if (seconds === 0) return buffer;\n\n    if (padStart < 0) throw new Error('Crunker: Parameter \"padStart\" in padAudio must be positive');\n    if (seconds < 0) throw new Error('Crunker: Parameter \"seconds\" in padAudio must be positive');\n\n    const updatedBuffer = this._context.createBuffer(\n      buffer.numberOfChannels,\n      Math.ceil(buffer.length + seconds * buffer.sampleRate),\n      buffer.sampleRate\n    );\n\n    for (let channelNumber = 0; channelNumber < buffer.numberOfChannels; channelNumber++) {\n      const channelData = buffer.getChannelData(channelNumber);\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(channelData.subarray(0, Math.ceil(padStart * buffer.sampleRate) + 1), 0);\n\n      updatedBuffer\n        .getChannelData(channelNumber)\n        .set(\n          channelData.subarray(Math.ceil(padStart * buffer.sampleRate) + 2, updatedBuffer.length + 1),\n          Math.ceil((padStart + seconds) * buffer.sampleRate)\n        );\n    }\n\n    return updatedBuffer;\n  }\n\n  /**\n   * Plays the provided AudioBuffer in an AudioBufferSourceNode.\n   */\n  play(buffer: AudioBuffer): AudioBufferSourceNode {\n    const source = this._context.createBufferSource();\n\n    source.buffer = buffer;\n    source.connect(this._context.destination);\n    source.start();\n\n    return source;\n  }\n\n  /**\n   * Exports the specified AudioBuffer to a Blob, Object URI and HTMLAudioElement.\n   *\n   * Note that changing the MIME type does not change the actual file format. The\n   * file format will **always** be a WAVE file due to how audio is stored in the\n   * browser.\n   *\n   * @param buffer Buffer to export\n   * @param type MIME type (default: `audio/wav`)\n   */\n  export(buffer: AudioBuffer, type: string = 'audio/wav'): ExportedCrunkerAudio {\n    const recorded = this._interleave(buffer);\n    const dataview = this._writeHeaders(recorded, buffer.numberOfChannels, buffer.sampleRate);\n    const audioBlob = new Blob([dataview], { type });\n\n    return {\n      blob: audioBlob,\n      url: this._renderURL(audioBlob),\n      element: this._renderAudioElement(audioBlob),\n    };\n  }\n\n  /**\n   * Downloads the provided Blob.\n   *\n   * @param blob Blob to download\n   * @param filename An optional file name to use for the download (default: `crunker`)\n   */\n  download(blob: Blob, filename: string = 'crunker'): HTMLAnchorElement {\n    const a = document.createElement('a');\n\n    a.style.display = 'none';\n    a.href = this._renderURL(blob);\n    a.download = `${filename}.${blob.type.split('/')[1]}`;\n    a.click();\n\n    return a;\n  }\n\n  /**\n   * Executes a callback if the browser does not support the Web Audio API.\n   *\n   * Returns the result of the callback, or `undefined` if the Web Audio API is supported.\n   *\n   * @param callback callback to run if the browser does not support the Web Audio API\n   */\n  notSupported<T>(callback: () => T): T | undefined {\n    return this._isSupported() ? undefined : callback();\n  }\n\n  /**\n   * Closes Crunker's internal AudioContext.\n   */\n  close(): this {\n    this._context.close();\n    return this;\n  }\n\n  /**\n   * Returns the largest duration of the longest AudioBuffer.\n   *\n   * @internal\n   */\n  private _maxDuration(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.duration));\n  }\n\n  /**\n   * Returns the largest number of channels in an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _maxNumberOfChannels(buffers: AudioBuffer[]): number {\n    return Math.max(...buffers.map((buffer) => buffer.numberOfChannels));\n  }\n\n  /**\n   * Returns the sum of the lengths of an array of AudioBuffers.\n   *\n   * @internal\n   */\n  private _totalLength(buffers: AudioBuffer[]): number {\n    return buffers.map((buffer) => buffer.length).reduce((a, b) => a + b, 0);\n  }\n\n  /**\n   * Returns whether the browser supports the Web Audio API.\n   *\n   * @internal\n   */\n  private _isSupported(): boolean {\n    return 'AudioContext' in window || 'webkitAudioContext' in window || 'mozAudioContext' in window;\n  }\n\n  /**\n   * Writes the WAV headers for the specified Float32Array.\n   *\n   * Returns a DataView containing the WAV headers and file content.\n   *\n   * @internal\n   */\n  private _writeHeaders(buffer: Float32Array, numOfChannels: number, sampleRate: number): DataView {\n    const bitDepth = 16;\n    const bytesPerSample = bitDepth / 8;\n    const sampleSize = numOfChannels * bytesPerSample;\n\n    const fileHeaderSize = 8;\n    const chunkHeaderSize = 36;\n    const chunkDataSize = buffer.length * bytesPerSample;\n    const chunkTotalSize = chunkHeaderSize + chunkDataSize;\n\n    const arrayBuffer = new ArrayBuffer(fileHeaderSize + chunkTotalSize);\n    const view = new DataView(arrayBuffer);\n\n    this._writeString(view, 0, 'RIFF');\n    view.setUint32(4, chunkTotalSize, true);\n    this._writeString(view, 8, 'WAVE');\n    this._writeString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, numOfChannels, true);\n    view.setUint32(24, sampleRate, true);\n    view.setUint32(28, sampleRate * sampleSize, true);\n    view.setUint16(32, sampleSize, true);\n    view.setUint16(34, bitDepth, true);\n    this._writeString(view, 36, 'data');\n    view.setUint32(40, chunkDataSize, true);\n\n    return this._floatTo16BitPCM(view, buffer, fileHeaderSize + chunkHeaderSize);\n  }\n\n  /**\n   * Converts a Float32Array to 16-bit PCM.\n   *\n   * @internal\n   */\n  private _floatTo16BitPCM(dataview: DataView, buffer: Float32Array, offset: number): DataView {\n    for (let i = 0; i < buffer.length; i++, offset += 2) {\n      const tmp = Math.max(-1, Math.min(1, buffer[i]));\n      dataview.setInt16(offset, tmp < 0 ? tmp * 0x8000 : tmp * 0x7fff, true);\n    }\n\n    return dataview;\n  }\n\n  /**\n   * Writes a string to a DataView at the specified offset.\n   *\n   * @internal\n   */\n  private _writeString(dataview: DataView, offset: number, header: string): void {\n    for (let i = 0; i < header.length; i++) {\n      dataview.setUint8(offset + i, header.charCodeAt(i));\n    }\n  }\n\n  /**\n   * Converts an AudioBuffer to a Float32Array.\n   *\n   * @internal\n   */\n  private _interleave(input: AudioBuffer): Float32Array {\n    const channels = Array.from({ length: input.numberOfChannels }, (_, i) => i);\n    const length = channels.reduce((prev, channelIdx) => prev + input.getChannelData(channelIdx).length, 0);\n    const result = new Float32Array(length);\n\n    let index = 0;\n    let inputIndex = 0;\n\n    // for 2 channels its like: [L[0], R[0], L[1], R[1], ... , L[n], R[n]]\n    while (index < length) {\n      channels.forEach((channelIdx) => {\n        result[index++] = input.getChannelData(channelIdx)[inputIndex];\n      });\n\n      inputIndex++;\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates an HTMLAudioElement whose source is the specified Blob.\n   *\n   * @internal\n   */\n  private _renderAudioElement(blob: Blob): HTMLAudioElement {\n    const audio = document.createElement('audio');\n\n    audio.controls = true;\n    audio.src = this._renderURL(blob);\n\n    return audio;\n  }\n\n  /**\n   * Creates an Object URL for the specified Blob.\n   *\n   * @internal\n   */\n  private _renderURL(blob: Blob): string {\n    return (window.URL || window.webkitURL).createObjectURL(blob);\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Crunker","sampleRate","this","_context","_createContext","_sampleRate","window","AudioContext","webkitAudioContext","mozAudioContext","async","filepaths","Promise","all","map","filepath","buffer","File","Blob","arrayBuffer","fetch","then","response","headers","has","includes","console","warn","split","decodeAudioData","buffers","output","createBuffer","_maxNumberOfChannels","_maxDuration","forEach","channelNumber","numberOfChannels","outputData","getChannelData","bufferData","i","length","set","_totalLength","offset","padStart","seconds","Error","updatedBuffer","Math","ceil","channelData","subarray","source","createBufferSource","connect","destination","start","type","recorded","_interleave","dataview","_writeHeaders","audioBlob","blob","url","_renderURL","element","_renderAudioElement","filename","a","document","createElement","style","display","href","download","click","callback","_isSupported","undefined","close","max","duration","reduce","b","numOfChannels","sampleSize","bitDepth","chunkDataSize","chunkTotalSize","ArrayBuffer","view","DataView","_writeString","setUint32","setUint16","_floatTo16BitPCM","fileHeaderSize","tmp","min","setInt16","header","setUint8","charCodeAt","input","channels","Array","from","_","prev","channelIdx","result","Float32Array","index","inputIndex","audio","controls","src","URL","webkitURL","createObjectURL"],"sourceRoot":""}