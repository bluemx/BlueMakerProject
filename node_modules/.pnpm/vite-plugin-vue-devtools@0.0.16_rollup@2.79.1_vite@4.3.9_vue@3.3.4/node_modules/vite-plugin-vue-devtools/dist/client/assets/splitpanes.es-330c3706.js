import { _ as _sfc_main$3 } from './VIcon.vue_vue_type_script_setup_true_lang-e30540ed.js';
import { v as defineComponent, o as openBlock, c as createBlock, q as normalizeClass, K as isRef, a1 as toRaw, $ as computed, r as resolveComponent, e as createElementBlock, i as renderList, z as unref, an as nanoid, x as createBaseVNode, y as toDisplayString, g as createCommentVNode, F as Fragment, Z as ref, u as createVNode, a4 as withModifiers, d as withDirectives, ao as vShow, ap as h, f as renderSlot, l as normalizeStyle } from './index-d1c9f78d.js';
import { a as isComputed, b as isArray, c as isMap, d as isSet, e as isRegExp, t as toRawType, f as isPlainObject, g as escape } from './index-45ea79cd.js';
import { u as useCopy, _ as _sfc_main$4 } from './VIconButton.vue_vue_type_script_setup_true_lang-c612d7f4.js';

const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "VExpandIcon",
  props: {
    value: { type: Boolean }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VIcon = _sfc_main$3;
      return openBlock(), createBlock(_component_VIcon, {
        class: normalizeClass(["material-symbols:arrow-right", {
          "transform rotate-90": __props.value
        }]),
        "text-5": "",
        "op-50": "",
        "n-transition": ""
      }, null, 8, ["class"]);
    };
  }
});

/* Injected with object hook! */

function getFuntionDetails(func) {
  let string = "";
  let matches = null;
  try {
    string = Function.prototype.toString.call(func);
    matches = String.prototype.match.call(string, /\([\s\S]*?\)/);
  } catch (e) {
  }
  const match = matches && matches[0];
  const args = typeof match === "string" ? match : "(?)";
  const name = typeof func.name === "string" ? func.name : "";
  return `<span style="opacity:.5;">function</span> ${escape(name)}${args}`;
}
function formatWithExtraType(value, type) {
  return `${value} <span style="color:#6b7280;padding:'0 5px';">(${type})</span>`;
}
function formatStateType(value) {
  if (isComputed(value)) {
    const state = formatStateType(value.value);
    return {
      ...state,
      ...state.recursive ? { rawDisplay: formatWithExtraType(state.rawDisplay, "Computed") } : { value: formatWithExtraType(state.value, "Computed") }
    };
  } else if (isRef(value)) {
    const state = formatStateType(toRaw(value.value));
    return {
      ...state,
      ...state.recursive ? { rawDisplay: formatWithExtraType(state.rawDisplay, "Ref") } : { value: formatWithExtraType(state.value, "Ref") }
    };
  } else if (isArray(value)) {
    return {
      rawType: "object",
      rawDisplay: `Array[${value.length}]`,
      recursive: true,
      value
    };
  } else if (typeof value === "function") {
    return {
      rawType: "function",
      recursive: false,
      value: getFuntionDetails(value)
    };
  } else if (typeof value === "bigint") {
    const stringifiedBigInt = BigInt.prototype.toString.call(value);
    return {
      rawType: "string",
      rawDisplay: `BigInt(${stringifiedBigInt})`,
      recursive: false,
      value: stringifiedBigInt
    };
  } else if (Number.isNaN(value)) {
    return {
      rawType: "literal",
      recursive: false,
      value: "NaN"
    };
  } else if (value === Infinity) {
    return {
      rawType: "literal",
      recursive: false,
      value: "Infinity"
    };
  } else if (value === -Infinity) {
    return {
      rawType: "literal",
      recursive: false,
      value: "-Infinity"
    };
  } else if (typeof value === "symbol") {
    return {
      rawType: "literal",
      recursive: false,
      value: Symbol.prototype.toString.call(value)
    };
  } else if (value === null) {
    return {
      rawType: "null",
      recursive: false,
      value: "null"
    };
  } else if (typeof value === "undefined") {
    return {
      rawType: "null",
      recursive: false,
      value: "undefined"
    };
  } else if (typeof value === "string") {
    return {
      rawType: "string",
      recursive: false,
      value: `"${value}"`
    };
  } else if (value !== "null" && typeof value === "object") {
    if (isMap(value)) {
      return {
        rawType: "object",
        rawDisplay: "Map",
        recursive: true,
        value: Array.from(value.entries()).map(([key, value2]) => ({ key, value: value2 }))
      };
    } else if (isSet(value)) {
      const list = Array.from(value);
      return {
        rawType: "object",
        rawDisplay: `Set[${list.length}]`,
        recursive: true,
        value: list
      };
    } else if (isRegExp(value)) {
      return {
        rawType: "string",
        recursive: false,
        value: RegExp.prototype.toString.call(value)
      };
    } else if (toRawType(value) === "Error") {
      return {
        rawType: "string",
        recursive: false,
        // @ts-expect-error skip
        value: `${value?.message}: ${value?.stack}`
      };
    } else if (value?.state && value._vm || value.constructor?.name === "Store" && value._wrappedGetters) {
      return {
        rawType: "string",
        recursive: false,
        value: '"[object Store]"'
      };
    } else if (value.constructor && value.constructor.name === "VueRouter" || value.currentRoute) {
      return {
        rawType: "string",
        recursive: false,
        value: '"[object Router]"'
      };
    } else if (typeof value.render === "function") {
      return {
        rawType: "object",
        recursive: false,
        // @ts-expect-error skip
        value: formatWithExtraType(value.__name, "Component") ?? "Vue Component"
      };
    } else if (isPlainObject(value)) {
      return {
        rawType: "object",
        rawDisplay: "Object",
        recursive: true,
        value
      };
    } else {
      return {
        rawType: "string",
        recursive: false,
        value: `"${toRawType(value)}"`
      };
    }
  } else {
    return {
      rawType: "literal",
      recursive: false,
      value
    };
  }
}

/* Injected with object hook! */

const _hoisted_1$1 = ["onClick"];
const _hoisted_2$1 = {
  key: 1,
  "inline-block": "",
  "h-6": "",
  "w-6": ""
};
const _hoisted_3 = {
  "text-purple-700": "",
  "dark:text-purple-300": ""
};
const _hoisted_4 = /* @__PURE__ */ createBaseVNode("span", {
  "px-1": "",
  "op-60": ""
}, ":", -1);
const _hoisted_5 = ["innerHTML"];
const _hoisted_6 = ["onClick", "innerHTML"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "StateFieldsTree",
  props: {
    id: null,
    data: null,
    depth: { default: 0 },
    expandedId: null
  },
  emits: ["updateExpanded"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const rawTypeStyles = { literal: "raw-literal", string: "raw-string", object: "raw-object", function: "raw-function", null: "raw-null" };
    const list = computed(() => {
      if (Array.isArray(props.data)) {
        return props.data.map((item) => {
          return formatStateType(item);
        });
      } else if (typeof props.data === "object" && props.data !== null) {
        const o = {};
        for (const k in props.data) {
          const key = k;
          o[key] = formatStateType(props.data[k]);
        }
        const sorted = {};
        Object.keys(o).sort().forEach((key) => {
          sorted[key] = o[key];
        });
        return sorted;
      } else {
        return formatStateType("");
      }
    });
    function toggleExpand(id) {
      emits("updateExpanded", id);
    }
    const copy = useCopy();
    return (_ctx, _cache) => {
      const _component_VExpandIcon = _sfc_main$2;
      const _component_StateFieldsTree = resolveComponent("StateFieldsTree", true);
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(list), (item, index) => {
        return openBlock(), createElementBlock("code", {
          key: unref(nanoid)(),
          block: "",
          "select-none": "",
          "pl-2": "",
          "text-sm": ""
        }, [
          createBaseVNode("p", {
            flex: "",
            "items-center": "",
            class: normalizeClass([item?.recursive && "cursor-pointer"]),
            onClick: ($event) => item?.recursive ? toggleExpand(`${__props.id}-${__props.depth}-${index}`) : () => {
            }
          }, [
            item?.recursive ? (openBlock(), createBlock(_component_VExpandIcon, {
              key: 0,
              value: __props.expandedId.includes(`${__props.id}-${__props.depth}-${index}`)
            }, null, 8, ["value"])) : (openBlock(), createElementBlock("i", _hoisted_2$1)),
            createBaseVNode("span", _hoisted_3, toDisplayString(index), 1),
            _hoisted_4,
            item?.recursive ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(rawTypeStyles[item.rawType]),
              "max-w": "[75%]",
              truncate: "",
              innerHTML: item?.rawDisplay
            }, null, 10, _hoisted_5)) : (openBlock(), createElementBlock("span", {
              key: 3,
              class: normalizeClass(rawTypeStyles[item.rawType]),
              "max-w": "[75%]",
              truncate: "",
              hover: "underline underline-offset-3 cursor-pointer",
              onClick: ($event) => unref(copy)(String(item?.value)),
              innerHTML: item?.value
            }, null, 10, _hoisted_6))
          ], 10, _hoisted_1$1),
          __props.expandedId.includes(`${__props.id}-${__props.depth}-${index}`) && item?.recursive ? (openBlock(), createBlock(_component_StateFieldsTree, {
            key: 0,
            id: __props.id,
            data: item?.value,
            depth: __props.depth + 1,
            "expanded-id": __props.expandedId,
            onUpdateExpanded: toggleExpand
          }, null, 8, ["id", "data", "depth", "expanded-id"])) : createCommentVNode("", true)
        ]);
      }), 128);
    };
  }
});

/* Injected with object hook! */

const _hoisted_1 = { "text-primary": "" };
const _hoisted_2 = { "pl-3": "" };
const expandedIdCache = ref([]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "StateFields",
  props: {
    data: null,
    id: { default: 0 }
  },
  setup(__props) {
    const isExpanded = ref(true);
    const copy = useCopy();
    function toggleExpanded() {
      isExpanded.value = !isExpanded.value;
    }
    function updateExpandedIdCache(id) {
      if (expandedIdCache.value.includes(id))
        expandedIdCache.value = expandedIdCache.value.filter((i) => i !== id);
      else
        expandedIdCache.value.push(id);
    }
    return (_ctx, _cache) => {
      const _component_VExpandIcon = _sfc_main$2;
      const _component_VIconButton = _sfc_main$4;
      const _component_StateFieldsTree = _sfc_main$1;
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("h3", {
          flex: "",
          "cursor-pointer": "",
          "items-center": "",
          "justify-between": "",
          rounded: "",
          "py-1": "",
          class: "hover:bg-[#c2e9d7] hover:dark:bg-[#2c3e50]",
          onClick: toggleExpanded
        }, [
          createBaseVNode("div", null, [
            createVNode(_component_VExpandIcon, { value: unref(isExpanded) }, null, 8, ["value"]),
            createBaseVNode("span", _hoisted_1, toDisplayString(__props.data.key), 1)
          ]),
          createVNode(_component_VIconButton, {
            mr2: "",
            "flex-none": "",
            title: `Copy ${__props.data.key} to clipboard`,
            icon: "carbon-copy",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => unref(copy)(JSON.stringify(__props.data.value)), ["stop"]))
          }, null, 8, ["title"])
        ]),
        withDirectives(createBaseVNode("div", _hoisted_2, [
          createVNode(_component_StateFieldsTree, {
            id: __props.id,
            data: __props.data.value,
            "expanded-id": unref(expandedIdCache),
            onUpdateExpanded: updateExpandedIdCache
          }, null, 8, ["id", "data", "expanded-id"])
        ], 512), [
          [vShow, unref(isExpanded)]
        ])
      ]);
    };
  }
});

/* Injected with object hook! */

const M = {
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((e, i) => (e[i.id] = i) && e, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((e) => {
        e.update && e.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(e, i) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = i;
    },
    onMouseMove(e) {
      this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit("resize", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    onSplitterClick(e, i) {
      "ontouchstart" in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === i ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, i), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = i, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[i]);
    },
    onSplitterDblClick(e, i) {
      let s = 0;
      this.panes = this.panes.map((n, t) => (n.size = t === i ? n.max : n.min, t !== i && (s += n.min), n)), this.panes[i].size -= s, this.$emit("pane-maximize", this.panes[i]), this.$emit("resized", this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })));
    },
    onPaneClick(e, i) {
      this.$emit("pane-click", this.indexedPanes[i]);
    },
    getCurrentMouseDrag(e) {
      const i = this.container.getBoundingClientRect(), { clientX: s, clientY: n } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
      return {
        x: s - i.left,
        y: n - i.top
      };
    },
    getCurrentDragPercentage(e) {
      e = e[this.horizontal ? "y" : "x"];
      const i = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (e = i - e), e * 100 / i;
    },
    calculatePanesSize(e) {
      const i = this.touch.activeSplitter;
      let s = {
        prevPanesSize: this.sumPrevPanesSize(i),
        nextPanesSize: this.sumNextPanesSize(i),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const n = 0 + (this.pushOtherPanes ? 0 : s.prevPanesSize), t = 100 - (this.pushOtherPanes ? 0 : s.nextPanesSize), a = Math.max(Math.min(this.getCurrentDragPercentage(e), t), n);
      let r = [i, i + 1], o = this.panes[r[0]] || null, h = this.panes[r[1]] || null;
      const l = o.max < 100 && a >= o.max + s.prevPanesSize, u = h.max < 100 && a <= 100 - (h.max + this.sumNextPanesSize(i + 1));
      if (l || u) {
        l ? (o.size = o.max, h.size = Math.max(100 - o.max - s.prevPanesSize - s.nextPanesSize, 0)) : (o.size = Math.max(100 - h.max - s.prevPanesSize - this.sumNextPanesSize(i + 1), 0), h.size = h.max);
        return;
      }
      if (this.pushOtherPanes) {
        const d = this.doPushOtherPanes(s, a);
        if (!d)
          return;
        (({ sums: s, panesToResize: r } = d)), o = this.panes[r[0]] || null, h = this.panes[r[1]] || null;
      }
      o !== null && (o.size = Math.min(Math.max(a - s.prevPanesSize - s.prevReachedMinPanes, o.min), o.max)), h !== null && (h.size = Math.min(Math.max(100 - a - s.nextPanesSize - s.nextReachedMinPanes, h.min), h.max));
    },
    doPushOtherPanes(e, i) {
      const s = this.touch.activeSplitter, n = [s, s + 1];
      return i < e.prevPanesSize + this.panes[n[0]].min && (n[0] = this.findPrevExpandedPane(s).index, e.prevReachedMinPanes = 0, n[0] < s && this.panes.forEach((t, a) => {
        a > n[0] && a <= s && (t.size = t.min, e.prevReachedMinPanes += t.min);
      }), e.prevPanesSize = this.sumPrevPanesSize(n[0]), n[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((t, a) => {
        a > 0 && a <= s && (t.size = t.min, e.prevReachedMinPanes += t.min);
      }), this.panes[n[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : i > 100 - e.nextPanesSize - this.panes[n[1]].min && (n[1] = this.findNextExpandedPane(s).index, e.nextReachedMinPanes = 0, n[1] > s + 1 && this.panes.forEach((t, a) => {
        a > s && a < n[1] && (t.size = t.min, e.nextReachedMinPanes += t.min);
      }), e.nextPanesSize = this.sumNextPanesSize(n[1] - 1), n[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((t, a) => {
        a < this.panesCount - 1 && a >= s + 1 && (t.size = t.min, e.nextReachedMinPanes += t.min);
      }), this.panes[n[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : { sums: e, panesToResize: n };
    },
    sumPrevPanesSize(e) {
      return this.panes.reduce((i, s, n) => i + (n < e ? s.size : 0), 0);
    },
    sumNextPanesSize(e) {
      return this.panes.reduce((i, s, n) => i + (n > e + 1 ? s.size : 0), 0);
    },
    findPrevExpandedPane(e) {
      return [...this.panes].reverse().find((s) => s.index < e && s.size > s.min) || {};
    },
    findNextExpandedPane(e) {
      return this.panes.find((s) => s.index > e + 1 && s.size > s.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((i) => {
        const s = i.classList.contains("splitpanes__pane"), n = i.classList.contains("splitpanes__splitter");
        !s && !n && (i.parentNode.removeChild(i), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      });
    },
    addSplitter(e, i, s = !1) {
      const n = e - 1, t = document.createElement("div");
      t.classList.add("splitpanes__splitter"), s || (t.onmousedown = (a) => this.onMouseDown(a, n), typeof window < "u" && "ontouchstart" in window && (t.ontouchstart = (a) => this.onMouseDown(a, n)), t.onclick = (a) => this.onSplitterClick(a, n + 1)), this.dblClickSplitter && (t.ondblclick = (a) => this.onSplitterDblClick(a, n + 1)), i.parentNode.insertBefore(t, i);
    },
    removeSplitter(e) {
      e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.parentNode.removeChild(e);
    },
    redoSplitters() {
      const e = Array.from(this.container.children);
      e.forEach((s) => {
        s.className.includes("splitpanes__splitter") && this.removeSplitter(s);
      });
      let i = 0;
      e.forEach((s) => {
        s.className.includes("splitpanes__pane") && (!i && this.firstSplitter ? this.addSplitter(i, s, !0) : i && this.addSplitter(i, s), i++);
      });
    },
    requestUpdate({ target: e, ...i }) {
      const s = this.indexedPanes[e._.uid];
      Object.entries(i).forEach(([n, t]) => s[n] = t);
    },
    onPaneAdd(e) {
      let i = -1;
      Array.from(e.$el.parentNode.children).some((t) => (t.className.includes("splitpanes__pane") && i++, t === e.$el));
      const s = parseFloat(e.minSize), n = parseFloat(e.maxSize);
      this.panes.splice(i, 0, {
        id: e._.uid,
        index: i,
        min: isNaN(s) ? 0 : s,
        max: isNaN(n) ? 100 : n,
        size: e.size === null ? null : parseFloat(e.size),
        givenSize: e.size,
        update: e.update
      }), this.panes.forEach((t, a) => t.index = a), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[i] }), this.$emit("pane-add", { index: i, panes: this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size })) });
      });
    },
    onPaneRemove(e) {
      const i = this.panes.findIndex((n) => n.id === e._.uid), s = this.panes.splice(i, 1)[0];
      this.panes.forEach((n, t) => n.index = t), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...s, index: i } }), this.$emit("pane-remove", { removed: s, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    resetPaneSizes(e = {}) {
      !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some((i) => i.givenSize !== null || i.min || i.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })));
    },
    equalize() {
      const e = 100 / this.panesCount;
      let i = 0;
      const s = [], n = [];
      this.panes.forEach((t) => {
        t.size = Math.max(Math.min(e, t.max), t.min), i -= t.size, t.size >= t.max && s.push(t.id), t.size <= t.min && n.push(t.id);
      }), i > 0.1 && this.readjustSizes(i, s, n);
    },
    initialPanesSizing() {
      let e = 100;
      const i = [], s = [];
      let n = 0;
      this.panes.forEach((a) => {
        e -= a.size, a.size !== null && n++, a.size >= a.max && i.push(a.id), a.size <= a.min && s.push(a.id);
      });
      let t = 100;
      e > 0.1 && (this.panes.forEach((a) => {
        a.size === null && (a.size = Math.max(Math.min(e / (this.panesCount - n), a.max), a.min)), t -= a.size;
      }), t > 0.1 && this.readjustSizes(e, i, s));
    },
    equalizeAfterAddOrRemove({ addedPane: e, removedPane: i } = {}) {
      let s = 100 / this.panesCount, n = 0;
      const t = [], a = [];
      e && e.givenSize !== null && (s = (100 - e.givenSize) / (this.panesCount - 1)), this.panes.forEach((r) => {
        n -= r.size, r.size >= r.max && t.push(r.id), r.size <= r.min && a.push(r.id);
      }), !(Math.abs(n) < 0.1) && (this.panes.forEach((r) => {
        e && e.givenSize !== null && e.id === r.id || (r.size = Math.max(Math.min(s, r.max), r.min)), n -= r.size, r.size >= r.max && t.push(r.id), r.size <= r.min && a.push(r.id);
      }), n > 0.1 && this.readjustSizes(n, t, a));
    },
    readjustSizes(e, i, s) {
      let n;
      e > 0 ? n = e / (this.panesCount - i.length) : n = e / (this.panesCount - s.length), this.panes.forEach((t, a) => {
        if (e > 0 && !i.includes(t.id)) {
          const r = Math.max(Math.min(t.size + n, t.max), t.min), o = r - t.size;
          e -= o, t.size = r;
        } else if (!s.includes(t.id)) {
          const r = Math.max(Math.min(t.size + n, t.max), t.min), o = r - t.size;
          e -= o, t.size = r;
        }
        t.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[t.id].size}%`
        });
      }), Math.abs(e) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
  },
  watch: {
    panes: {
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(e) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((s, n) => {
        s.ondblclick = e ? (t) => this.onSplitterDblClick(t, n) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return h(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, S = (e, i) => {
  const s = e.__vccOpts || e;
  for (const [n, t] of i)
    s[n] = t;
  return s;
}, x = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    update(e) {
      this.style = e;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(e) {
      this.requestUpdate({ target: this, size: e });
    },
    minSizeNumber(e) {
      this.requestUpdate({ target: this, min: e });
    },
    maxSizeNumber(e) {
      this.requestUpdate({ target: this, max: e });
    }
  }
};
function P(e, i, s, n, t, a) {
  return openBlock(), createElementBlock("div", {
    class: "splitpanes__pane",
    onClick: i[0] || (i[0] = (r) => a.onPaneClick(r, e._.uid)),
    style: normalizeStyle(e.style)
  }, [
    renderSlot(e.$slots, "default")
  ], 4);
}
const g = /* @__PURE__ */ S(x, [["render", P]]);

/* Injected with object hook! */

export { M, _sfc_main as _, _sfc_main$2 as a, g };
