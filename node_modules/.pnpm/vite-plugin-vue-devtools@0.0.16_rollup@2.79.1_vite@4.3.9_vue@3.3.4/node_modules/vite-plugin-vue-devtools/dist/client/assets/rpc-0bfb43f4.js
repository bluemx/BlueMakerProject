import { az as __vitePreload } from './index-d1c9f78d.js';

const DEFAULT_TIMEOUT = 6e4;
function defaultSerialize(i) {
  return i;
}
const defaultDeserialize = defaultSerialize;
const { setTimeout } = globalThis;
function createBirpc(functions, options) {
  const {
    post,
    on,
    eventNames = [],
    serialize = defaultSerialize,
    deserialize = defaultDeserialize,
    resolver,
    timeout = DEFAULT_TIMEOUT
  } = options;
  const rpcPromiseMap = /* @__PURE__ */ new Map();
  let _promise;
  const rpc = new Proxy({}, {
    get(_, method) {
      if (method === "$functions")
        return functions;
      const sendEvent = (...args) => {
        post(serialize({ m: method, a: args, t: "q" }));
      };
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = async (...args) => {
        await _promise;
        return new Promise((resolve, reject) => {
          const id = nanoid();
          rpcPromiseMap.set(id, { resolve, reject });
          post(serialize({ m: method, a: args, i: id, t: "q" }));
          if (timeout >= 0) {
            setTimeout(() => {
              reject(new Error(`[birpc] timeout on calling "${method}"`));
              rpcPromiseMap.delete(id);
            }, timeout);
          }
        });
      };
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  _promise = on(async (data, ...extra) => {
    const msg = deserialize(data);
    if (msg.t === "q") {
      const { m: method, a: args } = msg;
      let result, error;
      const fn = resolver ? resolver(method, functions[method]) : functions[method];
      if (!fn) {
        error = new Error(`[birpc] function "${method}" not found`);
      } else {
        try {
          result = await fn.apply(rpc, args);
        } catch (e) {
          error = e;
        }
      }
      if (msg.i) {
        if (error && options.onError)
          options.onError(error, method, args);
        post(serialize({ t: "s", i: msg.i, r: result, e: error }), ...extra);
      }
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = rpcPromiseMap.get(ack);
      if (promise) {
        if (error)
          promise.reject(error);
        else
          promise.resolve(result);
      }
      rpcPromiseMap.delete(ack);
    }
  });
  return rpc;
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[Math.random() * 64 | 0];
  return id;
}

/* Injected with object hook! */

function createRPCClient(name, hot, functions = {}) {
  const event = `${name}:rpc`;
  return createBirpc(
    functions,
    {
      on: async (fn) => {
        (await hot).on(event, fn);
      },
      post: async (data) => {
        (await hot).send(event, data);
      }
    }
  );
}

/* Injected with object hook! */

async function getViteClient(base = "/", warning = true) {
  try {
    return await __vitePreload(() => import(
      /* @vite-ignore */
      `${base}@vite/client`
    ),true?[]:void 0,import.meta.url);
  } catch {
    if (warning)
      console.error(`[vite-plugin-hot] Failed to import "${base}@vite/client"`);
  }
  return void 0;
}
async function createHotContext(path = "/____", base = "/") {
  const viteClient = await getViteClient(base);
  return viteClient?.createHotContext(path);
}

/* Injected with object hook! */

const rpc = createRPCClient("vite-plugin-vue-devtools", await createHotContext("/___", `${location.pathname.split("/__devtools")[0] || ""}/`.replace(/\/\//g, "/")));
const inspectClientUrl = await rpc.inspectClientUrl();

/* Injected with object hook! */

export { inspectClientUrl as i, rpc as r };
