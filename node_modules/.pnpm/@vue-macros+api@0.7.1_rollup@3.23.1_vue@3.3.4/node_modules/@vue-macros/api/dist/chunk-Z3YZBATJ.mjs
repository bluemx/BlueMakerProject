// src/resolve.ts
import { existsSync as existsSync2 } from "fs";
import { readFile as readFile2 } from "fs/promises";
import path2 from "path";

// src/ts/create.ts
function createUnionType(types) {
  return {
    type: "TSUnionType",
    types
  };
}
function createStringLiteral(value) {
  return {
    type: "StringLiteral",
    value,
    extra: {
      rawValue: value,
      raw: JSON.stringify(value)
    }
  };
}
function createTSLiteralType(literal) {
  return {
    type: "TSLiteralType",
    literal
  };
}

// src/ts/impl.ts
import { existsSync } from "fs";
import path from "path";
var resolveTSFileIdImpl = resolveTSFileIdNode;
function resolveTSFileId(id, importer) {
  return resolveTSFileIdImpl(id, importer);
}
function resolveTSFileIdNode(id, importer) {
  function tryResolve(id2, importer2) {
    const filePath = path.resolve(importer2, "..", id2);
    if (!existsSync(filePath))
      return;
    return filePath;
  }
  return tryResolve(id, importer) || tryResolve(`${id}.ts`, importer) || tryResolve(`${id}.d.ts`, importer) || tryResolve(`${id}/index`, importer) || tryResolve(`${id}/index.ts`, importer) || tryResolve(`${id}/index.d.ts`, importer);
}
function setResolveTSFileIdImpl(impl) {
  resolveTSFileIdImpl = impl;
}

// src/ts/is.ts
import { isDeclaration } from "@babel/types";
function isTSDeclaration(node) {
  return isDeclaration(node) && node.type.startsWith("TS");
}

// src/ts/resolve-reference.ts
import {
  isTSType
} from "@babel/types";

// src/ts/resolve.ts
import { resolveLiteral as resolveLiteral2, resolveObjectKey } from "@vue-macros/common";

// src/ts/property.ts
import { resolveLiteral } from "@vue-macros/common";
function mergeTSProperties(a, b) {
  return {
    callSignatures: [...a.callSignatures, ...b.callSignatures],
    constructSignatures: [...a.constructSignatures, ...b.constructSignatures],
    methods: { ...a.methods, ...b.methods },
    properties: { ...a.properties, ...b.properties }
  };
}
function checkForTSProperties(node) {
  return !!node && [
    "TSInterfaceDeclaration",
    "TSInterfaceBody",
    "TSTypeLiteral",
    "TSIntersectionType",
    "TSMappedType",
    "TSFunctionType"
  ].includes(node.type);
}
async function resolveTSProperties({
  type,
  scope
}) {
  switch (type.type) {
    case "TSInterfaceBody":
      return resolveTypeElements(scope, type.body);
    case "TSTypeLiteral":
      return resolveTypeElements(scope, type.members);
    case "TSInterfaceDeclaration": {
      let properties = resolveTypeElements(scope, type.body.body);
      if (type.extends) {
        const resolvedExtends = (await Promise.all(
          type.extends.map(
            (node) => node.expression.type === "Identifier" ? resolveTSReferencedType({
              scope,
              type: node.expression
            }) : void 0
          )
        )).filter(filterValidExtends);
        if (resolvedExtends.length > 0) {
          const ext = (await Promise.all(
            resolvedExtends.map((resolved) => resolveTSProperties(resolved))
          )).reduceRight((acc, curr) => mergeTSProperties(acc, curr));
          properties = mergeTSProperties(ext, properties);
        }
      }
      return properties;
    }
    case "TSIntersectionType": {
      let properties = {
        callSignatures: [],
        constructSignatures: [],
        methods: {},
        properties: {}
      };
      for (const subType of type.types) {
        const resolved = await resolveTSReferencedType({
          scope,
          type: subType
        });
        if (!filterValidExtends(resolved))
          continue;
        properties = mergeTSProperties(
          properties,
          await resolveTSProperties(resolved)
        );
      }
      return properties;
    }
    case "TSMappedType": {
      const properties = {
        callSignatures: [],
        constructSignatures: [],
        methods: {},
        properties: {}
      };
      if (!type.typeParameter.constraint)
        return properties;
      const constraint = await resolveTSReferencedType({
        type: type.typeParameter.constraint,
        scope
      });
      if (!constraint || isTSNamespace(constraint))
        return properties;
      const types = resolveMaybeTSUnion(constraint.type);
      for (const subType of types) {
        if (subType.type !== "TSLiteralType")
          continue;
        const literal = await resolveTSLiteralType({
          type: subType,
          scope: constraint.scope
        });
        if (!literal)
          continue;
        const keys = resolveMaybeTSUnion(literal).map(
          (literal2) => String(resolveLiteral(literal2))
        );
        for (const key of keys) {
          properties.properties[String(key)] = {
            value: type.typeAnnotation ? { scope, type: type.typeAnnotation } : null,
            optional: type.optional === "+" || type.optional === true,
            signature: { type, scope }
          };
        }
      }
      return properties;
    }
    case "TSFunctionType": {
      const properties = {
        callSignatures: [{ type, scope }],
        constructSignatures: [],
        methods: {},
        properties: {}
      };
      return properties;
    }
    default:
      throw new Error(`unknown node: ${type == null ? void 0 : type.type}`);
  }
  function filterValidExtends(node) {
    return !isTSNamespace(node) && checkForTSProperties(node == null ? void 0 : node.type);
  }
}
function getTSPropertiesKeys(properties) {
  return [
    .../* @__PURE__ */ new Set([
      ...Object.keys(properties.properties),
      ...Object.keys(properties.methods)
    ])
  ];
}

// src/ts/resolve.ts
function resolveReferenceName(node) {
  if (node.type === "TSTypeReference") {
    return resolveReferenceName(node.typeName);
  } else if (node.type === "Identifier")
    return [node];
  else {
    return [...resolveReferenceName(node.left), node.right];
  }
}
async function resolveTSTemplateLiteral({
  type,
  scope
}) {
  const types = (await resolveKeys("", type.quasis, type.expressions)).map(
    (k) => createStringLiteral(k)
  );
  return types;
  async function resolveKeys(prefix, quasis, expressions) {
    var _a;
    if (expressions.length === 0) {
      return [prefix + (((_a = quasis[0]) == null ? void 0 : _a.value.cooked) ?? "")];
    }
    const [expr, ...restExpr] = expressions;
    const [quasi, ...restQuasis] = quasis;
    const subTypes = resolveMaybeTSUnion(expr);
    const keys = [];
    for (const type2 of subTypes) {
      if (!isSupportedForTSReferencedType(type2))
        continue;
      const resolved = await resolveTSReferencedType({
        type: type2,
        scope
      });
      if (!resolved || isTSNamespace(resolved))
        continue;
      const types2 = resolveMaybeTSUnion(resolved.type);
      for (const type3 of types2) {
        if (type3.type !== "TSLiteralType")
          continue;
        const literal = await resolveTSLiteralType({ type: type3, scope });
        if (!literal)
          continue;
        const subKeys = resolveMaybeTSUnion(literal).map(
          (literal2) => String(resolveLiteral2(literal2))
        );
        for (const key of subKeys) {
          const newPrefix = prefix + quasi.value.cooked + String(key);
          keys.push(...await resolveKeys(newPrefix, restQuasis, restExpr));
        }
      }
    }
    return keys;
  }
}
async function resolveTSLiteralType({
  type,
  scope
}) {
  if (type.literal.type === "UnaryExpression")
    return;
  if (type.literal.type === "TemplateLiteral") {
    const types = await resolveTSTemplateLiteral({ type: type.literal, scope });
    return types;
  }
  return type.literal;
}
function resolveTypeElements(scope, elements) {
  var _a;
  const properties = {
    callSignatures: [],
    constructSignatures: [],
    methods: {},
    properties: {}
  };
  const tryGetKey = (element) => {
    try {
      return resolveObjectKey(element.key, element.computed, false);
    } catch {
    }
  };
  for (const element of elements) {
    switch (element.type) {
      case "TSCallSignatureDeclaration":
        properties.callSignatures.push({ scope, type: element });
        break;
      case "TSConstructSignatureDeclaration":
        properties.constructSignatures.push({ scope, type: element });
        break;
      case "TSMethodSignature": {
        const key = tryGetKey(element);
        if (!key)
          continue;
        if (properties.properties[key])
          continue;
        if (!properties.methods[key])
          properties.methods[key] = [];
        if (element.typeAnnotation) {
          properties.methods[key].push({ scope, type: element });
        }
        break;
      }
      case "TSPropertySignature": {
        const key = tryGetKey(element);
        if (!key)
          continue;
        if (!properties.properties[key] && !properties.methods[key]) {
          const type = (_a = element.typeAnnotation) == null ? void 0 : _a.typeAnnotation;
          properties.properties[key] = {
            value: type ? { type, scope } : null,
            optional: !!element.optional,
            signature: { type: element, scope }
          };
        }
        break;
      }
      case "TSIndexSignature":
        break;
    }
  }
  return properties;
}
async function resolveTSIndexedAccessType({ scope, type }, stacks = []) {
  const object = await resolveTSReferencedType(
    { type: type.objectType, scope },
    stacks
  );
  if (!object || isTSNamespace(object))
    return void 0;
  const objectType = object.type;
  if (type.indexType.type === "TSNumberKeyword") {
    let types;
    if (objectType.type === "TSArrayType") {
      types = [objectType.elementType];
    } else if (objectType.type === "TSTupleType") {
      types = objectType.elementTypes.map(
        (t) => t.type === "TSNamedTupleMember" ? t.elementType : t
      );
    } else if (objectType.type === "TSTypeReference" && objectType.typeName.type === "Identifier" && objectType.typeName.name === "Array" && objectType.typeParameters) {
      types = objectType.typeParameters.params;
    } else {
      return void 0;
    }
    return { type: createUnionType(types), scope };
  } else if (objectType.type !== "TSInterfaceDeclaration" && objectType.type !== "TSTypeLiteral" && objectType.type !== "TSIntersectionType" && objectType.type !== "TSMappedType" && objectType.type !== "TSFunctionType")
    return void 0;
  const properties = await resolveTSProperties({
    type: objectType,
    scope: object.scope
  });
  const indexTypes = resolveMaybeTSUnion(type.indexType);
  const indexes = [];
  let optional = false;
  for (const index of indexTypes) {
    let keys;
    if (index.type === "TSLiteralType") {
      const literal = await resolveTSLiteralType({
        type: index,
        scope: object.scope
      });
      if (!literal)
        continue;
      keys = resolveMaybeTSUnion(literal).map(
        (literal2) => String(resolveLiteral2(literal2))
      );
    } else if (index.type === "TSTypeOperator") {
      const keysStrings = await resolveTSTypeOperator({
        type: index,
        scope: object.scope
      });
      if (!keysStrings)
        continue;
      keys = resolveMaybeTSUnion(keysStrings).map(
        (literal) => String(resolveLiteral2(literal))
      );
    } else
      continue;
    for (const key of keys) {
      const property = properties.properties[key];
      if (property) {
        optional || (optional = property.optional);
        const propertyType = properties.properties[key].value;
        if (propertyType)
          indexes.push(propertyType.type);
      }
      const methods = properties.methods[key];
      if (methods) {
        optional || (optional = methods.some((m) => !!m.type.optional));
        indexes.push(
          ...methods.map(
            ({ type: type2 }) => ({
              ...type2,
              type: "TSFunctionType"
            })
          )
        );
      }
    }
  }
  if (indexes.length === 0)
    return void 0;
  if (optional)
    indexes.push({ type: "TSUndefinedKeyword" });
  return { type: createUnionType(indexes), scope };
}
async function resolveTSTypeOperator({ scope, type }, stacks = []) {
  if (type.operator !== "keyof")
    return void 0;
  const resolved = await resolveTSReferencedType(
    {
      type: type.typeAnnotation,
      scope
    },
    stacks
  );
  if (!resolved || isTSNamespace(resolved))
    return void 0;
  const { type: resolvedType, scope: resolvedScope } = resolved;
  if (!checkForTSProperties(resolvedType))
    return void 0;
  const properties = await resolveTSProperties({
    type: resolvedType,
    scope: resolvedScope
  });
  return getTSPropertiesKeys(properties).map((k) => createStringLiteral(k));
}
function resolveMaybeTSUnion(node) {
  if (Array.isArray(node))
    return node;
  if (node.type === "TSUnionType")
    return node.types.flatMap((t) => resolveMaybeTSUnion(t));
  return [node];
}

// src/ts/scope.ts
import { readFile } from "fs/promises";
import {
  REGEX_SUPPORTED_EXT,
  babelParse,
  getFileCodeAndLang
} from "@vue-macros/common";
var tsFileCache = {};
async function getTSFile(filePath) {
  if (tsFileCache[filePath])
    return tsFileCache[filePath];
  const content = await readFile(filePath, "utf-8");
  const { code, lang } = getFileCodeAndLang(content, filePath);
  return tsFileCache[filePath] = {
    kind: "file",
    filePath,
    content,
    ast: REGEX_SUPPORTED_EXT.test(filePath) ? babelParse(code, lang).body : void 0
  };
}
function resolveTSScope(scope) {
  const isFile = scope.kind === "file";
  let parentScope;
  if (!isFile)
    parentScope = resolveTSScope(scope.scope);
  const file = isFile ? scope : parentScope.file;
  const body = isFile ? scope.ast : scope.ast.body;
  const exports = scope.exports;
  const declarations = isFile ? scope.declarations : { ...resolveTSScope(scope.scope).declarations, ...scope.declarations };
  return {
    isFile,
    file,
    body,
    declarations,
    exports
  };
}

// src/ts/resolve-reference.ts
function isSupportedForTSReferencedType(node) {
  return isTSType(node) || node.type === "Identifier" || isTSDeclaration(node);
}
async function resolveTSReferencedType(ref, stacks = []) {
  const { scope, type } = ref;
  if (stacks.some((stack) => stack.scope === scope && stack.type === type)) {
    return ref;
  }
  stacks.push(ref);
  switch (type.type) {
    case "TSTypeAliasDeclaration":
    case "TSParenthesizedType":
      return resolveTSReferencedType(
        { scope, type: type.typeAnnotation },
        stacks
      );
    case "TSIndexedAccessType":
      return resolveTSIndexedAccessType({ type, scope }, stacks);
    case "TSModuleDeclaration": {
      if (type.body.type === "TSModuleBlock") {
        const newScope = {
          kind: "module",
          ast: type.body,
          scope
        };
        await resolveTSNamespace(newScope);
        return newScope.exports;
      }
      return void 0;
    }
  }
  if (type.type !== "Identifier" && type.type !== "TSTypeReference")
    return { scope, type };
  await resolveTSNamespace(scope);
  const refNames = resolveReferenceName(type).map((id) => id.name);
  let resolved = resolveTSScope(scope).declarations;
  for (const name of refNames) {
    if (isTSNamespace(resolved) && resolved[name]) {
      resolved = resolved[name];
    } else if (type.type === "TSTypeReference") {
      return { type, scope };
    }
  }
  return resolved;
}

// src/ts/namespace.ts
var namespaceSymbol = Symbol("namespace");
function isTSNamespace(val) {
  return !!val && typeof val === "object" && namespaceSymbol in val;
}
async function resolveTSNamespace(scope) {
  var _a, _b;
  if (scope.exports)
    return;
  const exports = {
    [namespaceSymbol]: true
  };
  scope.exports = exports;
  const declarations = {
    [namespaceSymbol]: true,
    ...scope.declarations
  };
  scope.declarations = declarations;
  const { body, file } = resolveTSScope(scope);
  for (const stmt of body || []) {
    if (stmt.type === "ExportDefaultDeclaration" && isTSDeclaration(stmt.declaration)) {
      exports["default"] = await resolveTSReferencedType({
        scope,
        type: stmt.declaration
      });
    } else if (stmt.type === "ExportAllDeclaration") {
      const resolved = await resolveTSFileId(stmt.source.value, file.filePath);
      if (!resolved)
        continue;
      const sourceScope = await getTSFile(resolved);
      await resolveTSNamespace(sourceScope);
      Object.assign(exports, sourceScope.exports);
    } else if (stmt.type === "ExportNamedDeclaration") {
      let sourceExports;
      if (stmt.source) {
        const resolved = await resolveTSFileId(stmt.source.value, file.filePath);
        if (!resolved)
          continue;
        const scope2 = await getTSFile(resolved);
        await resolveTSNamespace(scope2);
        sourceExports = scope2.exports;
      } else {
        sourceExports = declarations;
      }
      for (const specifier of stmt.specifiers) {
        let exported;
        if (specifier.type === "ExportDefaultSpecifier") {
          exported = sourceExports["default"];
        } else if (specifier.type === "ExportNamespaceSpecifier") {
          exported = sourceExports;
        } else if (specifier.type === "ExportSpecifier") {
          exported = sourceExports[specifier.local.name];
        } else {
          throw new Error(`Unknown export type: ${specifier.type}`);
        }
        const name = specifier.exported.type === "Identifier" ? specifier.exported.name : specifier.exported.value;
        exports[name] = exported;
      }
      if (isTSDeclaration(stmt.declaration)) {
        const decl = stmt.declaration;
        if (((_a = decl.id) == null ? void 0 : _a.type) === "Identifier") {
          const exportedName = decl.id.name;
          declarations[exportedName] = exports[exportedName] = await resolveTSReferencedType({
            scope,
            type: decl
          });
        }
      }
    } else if (isTSDeclaration(stmt)) {
      if (((_b = stmt.id) == null ? void 0 : _b.type) !== "Identifier")
        continue;
      declarations[stmt.id.name] = await resolveTSReferencedType({
        scope,
        type: stmt
      });
    } else if (stmt.type === "ImportDeclaration") {
      const resolved = await resolveTSFileId(stmt.source.value, file.filePath);
      if (!resolved)
        continue;
      const importScope = await getTSFile(resolved);
      await resolveTSNamespace(importScope);
      const exports2 = importScope.exports;
      for (const specifier of stmt.specifiers) {
        const local = specifier.local.name;
        let imported;
        if (specifier.type === "ImportDefaultSpecifier") {
          imported = exports2["default"];
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          imported = exports2;
        } else if (specifier.type === "ImportSpecifier") {
          const name = specifier.imported.type === "Identifier" ? specifier.imported.name : specifier.imported.value;
          imported = exports2[name];
        } else {
          throw new Error(`Unknown import type: ${specifier.type}`);
        }
        declarations[local] = imported;
      }
    }
  }
}

// src/resolve.ts
var RollupResolve = () => {
  const referencedFiles = /* @__PURE__ */ new Map();
  function collectReferencedFile(importer, file) {
    if (!importer)
      return;
    if (!referencedFiles.has(file)) {
      referencedFiles.set(file, /* @__PURE__ */ new Set([importer]));
    } else {
      referencedFiles.get(file).add(importer);
    }
  }
  const resolveCache = /* @__PURE__ */ new Map();
  function withResolveCache(id, importer, result) {
    if (!resolveCache.has(importer)) {
      resolveCache.set(importer, /* @__PURE__ */ new Map([[id, result]]));
      return result;
    }
    resolveCache.get(importer).set(id, result);
    return result;
  }
  const resolve = (ctx) => async (id, importer) => {
    var _a;
    async function tryPkgEntry() {
      var _a2;
      try {
        const pkgPath = (_a2 = await ctx.resolve(`${id}/package.json`, importer)) == null ? void 0 : _a2.id;
        if (!pkgPath)
          return;
        const pkg = JSON.parse(await readFile2(pkgPath, "utf-8"));
        const types = pkg.types || pkg.typings;
        if (!types)
          return;
        const entry = path2.resolve(pkgPath, "..", types);
        return existsSync2(entry) ? entry : void 0;
      } catch {
      }
    }
    const tryResolve = async (id2) => {
      var _a2, _b;
      try {
        return ((_a2 = await ctx.resolve(id2, importer)) == null ? void 0 : _a2.id) || ((_b = await ctx.resolve(`${id2}.d`, importer)) == null ? void 0 : _b.id);
      } catch {
      }
      return;
    };
    const cached = (_a = resolveCache.get(importer)) == null ? void 0 : _a.get(id);
    if (cached)
      return cached;
    if (!id.startsWith(".")) {
      const entry = await tryPkgEntry();
      if (entry)
        return withResolveCache(id, importer, entry);
    }
    let resolved = await tryResolve(id);
    if (!resolved)
      return;
    if (existsSync2(resolved)) {
      collectReferencedFile(importer, resolved);
      return withResolveCache(id, importer, resolved);
    }
    resolved = await tryResolve(resolved);
    if (resolved && existsSync2(resolved)) {
      collectReferencedFile(importer, resolved);
      return withResolveCache(id, importer, resolved);
    }
  };
  const handleHotUpdate = ({
    file,
    server,
    modules
  }) => {
    const cache = /* @__PURE__ */ new Map();
    function getAffectedModules(file2) {
      if (cache.has(file2))
        return cache.get(file2);
      if (!referencedFiles.has(file2))
        return /* @__PURE__ */ new Set([]);
      const modules2 = /* @__PURE__ */ new Set([]);
      cache.set(file2, modules2);
      for (const importer of referencedFiles.get(file2)) {
        const mods = server.moduleGraph.getModulesByFile(importer);
        if (mods)
          mods.forEach((m) => modules2.add(m));
        getAffectedModules(importer).forEach((m) => modules2.add(m));
      }
      return modules2;
    }
    if (tsFileCache[file])
      delete tsFileCache[file];
    const affected = getAffectedModules(file);
    return [...modules, ...affected];
  };
  return {
    resolve,
    handleHotUpdate
  };
};

export {
  createUnionType,
  createStringLiteral,
  createTSLiteralType,
  resolveTSFileId,
  resolveTSFileIdNode,
  setResolveTSFileIdImpl,
  isTSDeclaration,
  mergeTSProperties,
  checkForTSProperties,
  resolveTSProperties,
  getTSPropertiesKeys,
  resolveReferenceName,
  resolveTSTemplateLiteral,
  resolveTSLiteralType,
  resolveTypeElements,
  resolveTSIndexedAccessType,
  resolveTSTypeOperator,
  resolveMaybeTSUnion,
  tsFileCache,
  getTSFile,
  resolveTSScope,
  isSupportedForTSReferencedType,
  resolveTSReferencedType,
  namespaceSymbol,
  isTSNamespace,
  resolveTSNamespace,
  RollupResolve
};
